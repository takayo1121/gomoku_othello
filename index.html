<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>五目オセロ（交点 / 安全手OFF / CPU最強 強30秒+ダブルスレット）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
  body{
    font-family:-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN",sans-serif;
    background:#f5f5f5;margin:0;padding:12px;
  }
  #status{font-weight:700;margin-bottom:8px}
  .controls{margin-bottom:10px}
  button,select{font-size:14px;margin-right:6px;padding:6px 10px}

  .board{
    width:min(92vw,520px);
    aspect-ratio:1/1;
    display:grid;
    grid-template-columns:repeat(9,1fr);
    background:#0a6a3a;
    border:2px solid #222;
  }

  .pt{
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
  }
  .pt::before{
    content:"";
    position:absolute;
    inset:0;
    background:
      linear-gradient(rgba(0,0,0,.35),rgba(0,0,0,.35)) center/100% 1px no-repeat,
      linear-gradient(90deg,rgba(0,0,0,.35),rgba(0,0,0,.35)) center/1px 100% no-repeat;
    opacity:.9;
  }

  .disabled{ cursor:not-allowed; opacity:.35; }

  .disc{
    width:62%;
    height:62%;
    border-radius:50%;
    box-shadow:0 2px 8px rgba(0,0,0,.35);
    border:1px solid rgba(0,0,0,.25);
    position:relative;
    z-index:3;
  }
  .black{background:#000;}
  .white{background:#fff;}

  .dot{
    width:10%;
    height:10%;
    border-radius:50%;
    background:rgba(0,0,0,.35);
    position:relative;
    z-index:2;
  }

  /* 安全手（表示ON時のみ） */
  .safe-fill{
    width:62%;
    height:62%;
    border-radius:50%;
    position:absolute;
    z-index:2;
    opacity:.85;
    box-shadow:0 2px 8px rgba(0,0,0,.22);
  }
  .safe-blue{ background:rgba(0,90,255,.92); } /* 黒番 */
  .safe-red{  background:rgba(220,0,0,.92); } /* 白番 */

  .note{font-size:12px;opacity:.85;line-height:1.5;margin-top:8px}

  /* 思考中オーバーレイ */
  #thinkingOverlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.20);
    z-index:9999;
    pointer-events:none;
  }
  #thinkingOverlay .label{
    font-size:22px;
    font-weight:800;
    color:#fff;
    text-shadow:0 2px 10px rgba(0,0,0,.55);
    padding:10px 14px;
    border-radius:12px;
    background:rgba(0,0,0,.35);
    backdrop-filter: blur(2px);
  }
</style>
</head>

<body>
  <div id="status">準備中…</div>

  <div class="controls">
    <button id="undoBtn">Undo</button>
    <button id="restartBtn">リスタート</button>

    <select id="mode">
      <option value="pvp">人 vs 人</option>
      <option value="cpu">人 vs CPU</option>
    </select>

    <!-- CPU戦のときだけ表示 -->
    <select id="humanColor" title="CPU戦：あなたの色" style="display:none">
      <option value="black">あなた：黒（先手）</option>
      <option value="white">あなた：白（後手）</option>
    </select>

    <!-- CPU戦のときだけ表示 -->
    <select id="difficulty" title="CPU難易度" style="display:none">
      <option value="easy">難易度：弱</option>
      <option value="medium">難易度：中</option>
      <option value="hard" selected>難易度：強（最強+）</option>
    </select>

    <button id="safeToggleBtn">安全手：OFF</button>
  </div>

  <div id="board" class="board"></div>

  <div id="thinkingOverlay"><div class="label">思考中…</div></div>

  <div class="note">
    「強（最強+）」：最大30秒探索＋候補手拡大＋ダブルスレット検出。3秒以上かかると「思考中…」表示。<br>
    安全手（塗り丸）は初期OFF。CPU戦ではCPU番の安全手は表示しません。
  </div>

<script>
(() => {
  const N=9, PLAY_MIN=1, PLAY_MAX=7;
  const EMPTY=0, BLACK=1, WHITE=2;
  const dirs8=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  const checkDirs=[[1,0],[0,1],[1,1],[1,-1]];

  let board, turn, gameOver, history;
  let showSafe = false;      // 安全手はデフォルトOFF
  let cpuThinking = false;
  let token = 0;             // 思考キャンセル用

  const $board=document.getElementById("board");
  const $status=document.getElementById("status");
  const $mode=document.getElementById("mode");
  const $humanColor=document.getElementById("humanColor");
  const $difficulty=document.getElementById("difficulty");
  const $safeBtn=document.getElementById("safeToggleBtn");
  const $overlay=document.getElementById("thinkingOverlay");

  const opp=c=>c===BLACK?WHITE:BLACK;
  const playable=(r,c)=>r>=PLAY_MIN&&r<=PLAY_MAX&&c>=PLAY_MIN&&c<=PLAY_MAX;
  const inB=(r,c)=>r>=0&&r<N&&c>=0&&c<N;
  const clone=b=>b.map(r=>r.slice());

  const isCpuMode=()=> $mode.value==="cpu";
  const human=()=> $humanColor.value==="black"?BLACK:WHITE;
  const cpu=()=> opp(human());
  const isHumanTurn=()=> !isCpuMode() || turn===human();

  function updateCpuUiVisibility(){
    const on = isCpuMode();
    $humanColor.style.display = on ? "" : "none";
    $difficulty.style.display = on ? "" : "none";
  }

  function showThinking(){ $overlay.style.display="flex"; }
  function hideThinking(){ $overlay.style.display="none"; }

  function init(){
    token++; // キャンセル
    cpuThinking=false;
    hideThinking();

    board=Array.from({length:N},()=>Array(N).fill(EMPTY));
    turn=BLACK; gameOver=false; history=[];
    updateCpuUiVisibility();
    render(); updateStatus();
    maybeCpu();
  }

  function flips(b,r,c,col){
    let f=[];
    for(const[dR,dC]of dirs8){
      let x=r+dR,y=c+dC,tmp=[];
      while(inB(x,y)&&b[x][y]===opp(col)){tmp.push([x,y]);x+=dR;y+=dC;}
      if(tmp.length&&inB(x,y)&&b[x][y]===col)f=f.concat(tmp);
    }
    return f;
  }

  function sim(b,r,c,col){
    if(!playable(r,c)||b[r][c]!==EMPTY)return null;
    const nb=clone(b); nb[r][c]=col;
    flips(nb,r,c,col).forEach(([x,y])=>nb[x][y]=col);
    return nb;
  }

  function hasFive(b,col){
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++)for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
      if(b[r][c]!==col)continue;
      for(const[dR,dC]of checkDirs){
        let n=1,x=r+dR,y=c+dC;
        while(playable(x,y)&&b[x][y]===col){ if(++n>=5) return true; x+=dR;y+=dC; }
      }
    }
    return false;
  }

  function legal(b){
    const m=[];
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++)for(let c=PLAY_MIN;c<=PLAY_MAX;c++)
      if(b[r][c]===EMPTY)m.push([r,c]);
    return m;
  }

  // 安全手（表示用）
  function safeMoves(b,col){
    const set=new Set(), o=opp(col);
    for(const[r,c]of legal(b)){
      const nb=sim(b,r,c,col);
      if(!nb)continue;
      if(hasFive(nb,col)){ set.add(`${r},${c}`); continue; }
      let oppWin=false;
      for(const[x,y]of legal(nb)){
        const nb2=sim(nb,x,y,o);
        if(nb2&&hasFive(nb2,o)){ oppWin=true; break; }
      }
      if(!oppWin)set.add(`${r},${c}`);
    }
    return set;
  }

  // ---------------------------
  // CPU 最強+（hard）：候補増 + ダブルスレット + 反復深化 + αβ + TT + yield
  // ---------------------------

  function anyStoneExists(b){
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++)for(let c=PLAY_MIN;c<=PLAY_MAX;c++)
      if(b[r][c]!==EMPTY) return true;
    return false;
  }

  function countStones(b){
    let n=0;
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++)for(let c=PLAY_MIN;c<=PLAY_MAX;c++)
      if(b[r][c]!==EMPTY) n++;
    return n;
  }

  // 候補：石の近傍（radius）+ “盤面が進んだら全合法” に近づける
  function candidateMoves(b, radius){
    if(!anyStoneExists(b)){
      return [[4,4],[4,3],[3,4],[4,5],[5,4],[3,3],[5,5],[3,5],[5,3]];
    }

    const stones = countStones(b);
    // 終盤は全部候補（読み切り寄せ）
    if(stones >= 34){ // 49のうち約70%埋まったら
      return legal(b);
    }

    const cand = new Set();
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++){
      for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
        if(b[r][c]===EMPTY) continue;
        for(let dr=-radius; dr<=radius; dr++){
          for(let dc=-radius; dc<=radius; dc++){
            const rr=r+dr, cc=c+dc;
            if(playable(rr,cc) && b[rr][cc]===EMPTY) cand.add(`${rr},${cc}`);
          }
        }
      }
    }

    const out=[];
    for(const s of cand){
      const [r,c]=s.split(",").map(Number);
      out.push([r,c]);
    }
    return out;
  }

  function lineFeature(b, r, c, col, dr, dc){
    let a=0, x=r+dr, y=c+dc;
    while(playable(x,y) && b[x][y]===col){ a++; x+=dr; y+=dc; }
    const end1 = (playable(x,y) && b[x][y]===EMPTY) ? 1 : 0;

    let bcnt=0; x=r-dr; y=c-dc;
    while(playable(x,y) && b[x][y]===col){ bcnt++; x-=dr; y-=dc; }
    const end2 = (playable(x,y) && b[x][y]===EMPTY) ? 1 : 0;

    return {len: 1+a+bcnt, openEnds: end1+end2};
  }

  // 「次の1手で勝てる手」がいくつあるか（=即勝ち手数）
  function countImmediateWins(b, col, candList){
    let cnt = 0;
    const moves = candList || legal(b);
    for(const [r,c] of moves){
      if(b[r][c]!==EMPTY) continue;
      const nb = sim(b,r,c,col);
      if(nb && hasFive(nb, col)) cnt++;
      // 2個以上あれば十分（ダブルスレット判定用）
      if(cnt >= 2) return 2;
    }
    return cnt;
  }

  // 評価（CPU視点）
  // - パターン（開いた四/三）を超重く
  // - “即勝ち手数”/“ダブルスレット”を明示的に評価
  function evaluate(b, cpuCol){
    const humCol = opp(cpuCol);
    if(hasFive(b, cpuCol)) return 1e15;
    if(hasFive(b, humCol)) return -1e15;

    let score = 0;

    // 中央寄り（軽く）
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++){
      for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
        const v=b[r][c];
        if(v===EMPTY) continue;
        const centerDist = Math.abs(r-4)+Math.abs(c-4);
        const w = 6 - centerDist;
        score += (v===cpuCol ? +w : -w);
      }
    }

    // パターン加点（重い）
    function addFor(col, sign){
      for(let r=PLAY_MIN;r<=PLAY_MAX;r++){
        for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
          if(b[r][c]!==col) continue;
          for(const [dr,dc] of checkDirs){
            const f=lineFeature(b, r, c, col, dr, dc);
            if(f.len>=4){
              if(f.openEnds===2) score += sign*1200000;   // 開いた四
              else if(f.openEnds===1) score += sign*260000;
              else score += sign*30000;
            }else if(f.len===3){
              if(f.openEnds===2) score += sign*35000;
              else if(f.openEnds===1) score += sign*9000;
              else score += sign*900;
            }else if(f.len===2){
              if(f.openEnds===2) score += sign*1200;
              else if(f.openEnds===1) score += sign*320;
              else score += sign*40;
            }
          }
        }
      }
    }
    addFor(cpuCol, +1);
    addFor(humCol, -1);

    // 即勝ち手数（=次で勝てる）＆ダブルスレット（2個以上）
    // ※候補を全探索しすぎないよう、近傍候補で見る（十分強い）
    const cand = candidateMoves(b, 3);
    const cpuWins = countImmediateWins(b, cpuCol, cand);
    const humWins = countImmediateWins(b, humCol, cand);

    if(cpuWins >= 2) score += 5e8;        // CPUのダブルスレット
    else if(cpuWins === 1) score += 8e6;  // CPUの単発脅威

    if(humWins >= 2) score -= 6e8;        // 相手のダブルスレットはより危険
    else if(humWins === 1) score -= 1.2e7;

    return score;
  }

  // TTキー：7x7 + 手番
  function keyOf(b, turnCol){
    let s = String(turnCol) + "|";
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++){
      for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
        s += b[r][c];
      }
    }
    return s;
  }

  function params(){
    const d = $difficulty.value;
    if(d==="easy")   return {timeMs: 100,   maxCand: 16, radius: 2, baseDepth: 1, yieldEvery: 1200};
    if(d==="medium") return {timeMs: 250,   maxCand: 16, radius: 2, baseDepth: 2, yieldEvery: 1500};
    // ★ 最強+: 最大30秒 / 候補増 / 半径拡大
    return            {timeMs: 30000, maxCand: 22, radius: 4, baseDepth: 3, yieldEvery: 1800};
  }

  // 手の並べ替え：
  // - 即勝ち
  // - 相手の即勝ちブロック
  // - “次手の即勝ち手数”が増える（ダブルスレット誘発）
  // - その後に局所連 + 評価
  function orderedMoves(b, col, maxCand, radius){
    const o = opp(col);
    const cand = candidateMoves(b, radius);
    const scored=[];

    // 相手が今すぐ勝つ手（それを塞ぐ手）を優先するため、相手勝ち手座標を先に集計
    // ※候補のみで見る（十分）
    const oppWinSquares = new Set();
    for(const [r,c] of cand){
      if(b[r][c]!==EMPTY) continue;
      const nb = sim(b,r,c,o);
      if(nb && hasFive(nb, o)) oppWinSquares.add(`${r},${c}`);
    }

    for(const [r,c] of cand){
      if(b[r][c]!==EMPTY) continue;
      const nb = sim(b,r,c,col);
      if(!nb) continue;

      const winNow = hasFive(nb, col) ? 1 : 0;
      const blocksOppWin = oppWinSquares.has(`${r},${c}`) ? 1 : 0;

      // ダブルスレット（次で勝てる手が2つ以上）を強く優先
      const nextCand = candidateMoves(nb, radius);
      const forks = countImmediateWins(nb, col, nextCand); // 0/1/2
      const forkBonus = (forks>=2) ? 1 : (forks===1 ? 0.2 : 0);

      let local=0;
      for(const [dr,dc] of checkDirs){
        const f=lineFeature(nb, r, c, col, dr, dc);
        local = Math.max(local, f.len*10 + f.openEnds*5);
      }

      const rough = evaluate(nb, col);

      const pri =
        winNow*1e18 +
        blocksOppWin*8e17 +
        forkBonus*4e16 +
        local*1e6 +
        rough;

      scored.push({r,c, pri});
    }

    scored.sort((a,b)=>b.pri-a.pri);
    return scored.slice(0, maxCand).map(x=>[x.r,x.c]);
  }

  async function yieldToUI(){
    await new Promise(requestAnimationFrame);
  }

  async function minimaxAsync(b, depth, alpha, beta, maximizing, cpuCol, turnCol, deadline, tt, ctx){
    // キャンセル/時間
    if(ctx.tok !== token) return evaluate(b, cpuCol);
    if(performance.now() > deadline) return evaluate(b, cpuCol);

    // 定期yield（UI更新/思考中表示を効かせる）
    ctx.nodes++;
    if(ctx.nodes % ctx.yieldEvery === 0){
      await yieldToUI();
      if(ctx.tok !== token) return evaluate(b, cpuCol);
      if(performance.now() > deadline) return evaluate(b, cpuCol);
    }

    const humCol = opp(cpuCol);

    // 終端
    if(hasFive(b, cpuCol)) return 1e15;
    if(hasFive(b, humCol)) return -1e15;

    // 0深さでも “即勝ち/即負け” を見てブレを減らす（簡易クワイエス）
    if(depth === 0){
      const cand = candidateMoves(b, 3);
      const cpuWins = countImmediateWins(b, cpuCol, cand);
      const humWins = countImmediateWins(b, humCol, cand);
      if(cpuWins >= 1) return 9e14;     // ほぼ勝ち
      if(humWins >= 1) return -9e14;    // ほぼ負け
      return evaluate(b, cpuCol);
    }

    const k = keyOf(b, turnCol) + "|d" + depth + "|m" + (maximizing?1:0);
    const cached = tt.get(k);
    if(cached !== undefined) return cached;

    const {maxCand, radius} = params();
    const moves = orderedMoves(b, turnCol, maxCand, radius);
    if(moves.length===0){
      const v = evaluate(b, cpuCol);
      tt.set(k, v);
      return v;
    }

    let best;
    if(maximizing){
      best = -Infinity;
      for(const [r,c] of moves){
        const nb = sim(b,r,c,turnCol);
        if(!nb) continue;
        const v = await minimaxAsync(nb, depth-1, alpha, beta, false, cpuCol, opp(turnCol), deadline, tt, ctx);
        if(v > best) best = v;
        if(best > alpha) alpha = best;
        if(beta <= alpha) break;
      }
    }else{
      best = Infinity;
      for(const [r,c] of moves){
        const nb = sim(b,r,c,turnCol);
        if(!nb) continue;
        const v = await minimaxAsync(nb, depth-1, alpha, beta, true, cpuCol, opp(turnCol), deadline, tt, ctx);
        if(v < best) best = v;
        if(best < beta) beta = best;
        if(beta <= alpha) break;
      }
    }

    tt.set(k, best);
    return best;
  }

  async function chooseCpuMoveAsync(){
    const cpuCol = cpu();
    const humCol = human();
    const {timeMs, maxCand, radius, baseDepth, yieldEvery} = params();

    // 即勝ち最優先
    const baseMoves = orderedMoves(board, cpuCol, maxCand, radius);
    for(const [r,c] of baseMoves){
      const nb = sim(board,r,c,cpuCol);
      if(nb && hasFive(nb, cpuCol)) return [r,c];
    }

    // 相手の即勝ち（可能ならブロック）
    const humCand = candidateMoves(board, radius);
    for(const [r,c] of humCand){
      if(board[r][c]!==EMPTY) continue;
      const nb = sim(board,r,c,humCol);
      if(nb && hasFive(nb, humCol)){
        if(playable(r,c)) return [r,c];
      }
    }

    const start = performance.now();
    const deadline = start + timeMs;

    // 3秒で「思考中…」
    const myTok = token;
    const thinkingTimer = setTimeout(() => {
      if(myTok === token && cpuThinking) showThinking();
    }, 3000);

    const tt = new Map();
    const ctx = { tok: myTok, nodes: 0, yieldEvery };

    let bestMove = baseMoves[0] || [4,4];
    let bestVal  = -Infinity;

    // 反復深化
    let depth = baseDepth;

    // iPhone向け安全上限（ただし30秒内で可能なら深く行く）
    const maxDepthCap = 14;

    while(performance.now() < deadline && ctx.tok === token){
      // PV優先：bestMoveを先頭に
      const moves = (() => {
        const m = orderedMoves(board, cpuCol, maxCand, radius);
        const key = `${bestMove[0]},${bestMove[1]}`;
        const idx = m.findIndex(x => `${x[0]},${x[1]}` === key);
        if(idx > 0){
          const [bm] = m.splice(idx,1);
          m.unshift(bm);
        }
        return m;
      })();

      let localBestMove = bestMove;
      let localBestVal  = -Infinity;

      for(const [r,c] of moves){
        if(performance.now() > deadline || ctx.tok !== token) break;
        const nb = sim(board, r, c, cpuCol);
        if(!nb) continue;

        const v = await minimaxAsync(nb, depth-1, -Infinity, Infinity, false, cpuCol, humCol, deadline, tt, ctx);
        if(v > localBestVal){
          localBestVal = v;
          localBestMove = [r,c];
        }
      }

      bestMove = localBestMove;
      bestVal  = localBestVal;

      depth++;
      if(depth > maxDepthCap) break;

      // 画面更新
      await yieldToUI();
    }

    clearTimeout(thinkingTimer);
    return bestMove;
  }

  // ---------------------------
  // ゲーム進行
  // ---------------------------

  function move(r,c){
    if(gameOver||!playable(r,c)||board[r][c]!==EMPTY)return;
    if(isCpuMode()&&!isHumanTurn())return;
    if(cpuThinking) return; // 思考中の誤操作防止

    history.push({board:clone(board),turn,gameOver});
    board[r][c]=turn;
    flips(board,r,c,turn).forEach(([x,y])=>board[x][y]=turn);

    if(hasFive(board,turn)){
      gameOver=true; render(); updateStatus(`${turn===BLACK?"黒":"白"}の勝ち！`);
      return;
    }
    turn=opp(turn); render(); updateStatus(); maybeCpu();
  }

  async function maybeCpu(){
    if(!isCpuMode()||gameOver||turn!==cpu()) return;

    cpuThinking = true;
    const myTok = ++token; // これ以降、このtoken以外はキャンセル扱い

    updateStatus();
    await new Promise(r => setTimeout(r, 0));

    try{
      const [r,c] = await chooseCpuMoveAsync();
      if(myTok !== token) return;

      history.push({board:clone(board),turn,gameOver});

      let rr=r, cc=c;
      if(!(playable(rr,cc) && board[rr][cc]===EMPTY)){
        const m = legal(board);
        if(!m.length) return;
        rr=m[0][0]; cc=m[0][1];
      }

      board[rr][cc]=turn;
      flips(board,rr,cc,turn).forEach(([x,y])=>board[x][y]=turn);

      if(hasFive(board,turn)){
        gameOver=true;
        render();
        hideThinking();
        cpuThinking=false;
        updateStatus(`${turn===BLACK?"黒":"白"}の勝ち！`);
        return;
      }

      turn=opp(turn);
      render();
      hideThinking();
      cpuThinking=false;
      updateStatus();
    }finally{
      hideThinking();
      cpuThinking=false;
      updateStatus();
    }
  }

  function updateStatus(msg){
    if(msg){ $status.textContent=msg; return; }
    if(gameOver){ $status.textContent="ゲーム終了"; return; }

    if(!isCpuMode()){
      $status.textContent = (turn===BLACK?"黒の手番":"白の手番");
      return;
    }
    const d = $difficulty.value==="easy"?"弱":$difficulty.value==="medium"?"中":"強（最強+）";
    $status.textContent = `手番：${turn===BLACK?"黒":"白"}${isHumanTurn()?"（あなた）":"（CPU）"} / 難易度：${d}`;
  }

  function render(){
    const show = showSafe && !gameOver && (!isCpuMode() || isHumanTurn());
    const safes = show ? safeMoves(board,turn) : new Set();
    const cls = turn===WHITE ? "safe-red" : "safe-blue";

    $board.innerHTML="";
    for(let r=0;r<N;r++)for(let c=0;c<N;c++){
      const cell=document.createElement("div");
      cell.className="pt"+(playable(r,c)?"":" disabled");
      cell.onclick=()=>move(r,c);

      if(board[r][c]){
        const d=document.createElement("div");
        d.className="disc "+(board[r][c]===BLACK?"black":"white");
        cell.appendChild(d);
      }else if(playable(r,c)){
        if(show && safes.has(`${r},${c}`)){
          const sf=document.createElement("div");
          sf.className="safe-fill "+cls;
          cell.appendChild(sf);
        }
        const dot=document.createElement("div");
        dot.className="dot";
        cell.appendChild(dot);
      }
      $board.appendChild(cell);
    }
  }

  // UIイベント
  document.getElementById("undoBtn").onclick=()=>{
    token++; // 思考キャンセル
    cpuThinking=false;
    hideThinking();

    if(!history.length) return;
    let s=history.pop(); board=clone(s.board); turn=s.turn; gameOver=s.gameOver;
    render(); updateStatus();

    // CPU戦は「あなたの手番」まで戻す
    if(isCpuMode() && !isHumanTurn() && history.length){
      s=history.pop(); board=clone(s.board); turn=s.turn; gameOver=s.gameOver;
      render(); updateStatus();
    }
  };

  document.getElementById("restartBtn").onclick=init;

  $mode.onchange=init;
  $humanColor.onchange=init;
  $difficulty.onchange=init;

  $safeBtn.onclick=()=>{
    showSafe=!showSafe;
    $safeBtn.textContent="安全手："+(showSafe?"ON":"OFF");
    render();
  };

  init();
})();
</script>
</body>
</html>
