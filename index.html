<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>五目オセロ（5個ちょうど勝利）</title>
<style>
  :root{
    --text:#e6eef8;
    --muted:#9fb0c5;
    --wood:#caa56a;
    --wood2:#b98f4f;
  }
  body{
    margin:0;
    background:linear-gradient(180deg,#0b0f14,#07111d);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:16px;
    gap:12px;
  }
  .wrap{
    width:min(980px, 100%);
    display:grid;
    grid-template-columns: 1fr;
    gap:12px;
  }
  @media(min-width:880px){
    .wrap{ grid-template-columns: 520px 1fr; align-items:start; }
  }
  .card{
    background:rgba(17,24,38,.88);
    border:1px solid rgba(43,58,82,.7);
    border-radius:14px;
    padding:12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .row > *{ margin:4px 0; }
  label{ font-size:13px; color:var(--muted); }
  select, button, input[type="checkbox"]{ font-size:14px; }
  select, button{
    background:#0f1726;
    color:var(--text);
    border:1px solid rgba(43,58,82,.8);
    border-radius:10px;
    padding:8px 10px;
  }
  button{ cursor:pointer; }
  button:hover{ border-color: rgba(74,163,255,.9); }
  button:disabled{ opacity:.45; cursor:not-allowed; }
  .tiny{ font-size:12px; color:var(--muted); }
  .status{ display:flex; flex-direction:column; gap:6px; font-size:14px; }
  .status strong{ font-size:16px; }
  canvas{
    width:100%;
    height:auto;
    border-radius:14px;
    background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.08), rgba(0,0,0,0) 45%),
                linear-gradient(135deg, var(--wood), var(--wood2));
    border:1px solid rgba(43,58,82,.8);
    touch-action: manipulation;
  }
  .hintdot{
    width:10px; height:10px; border-radius:50%;
    display:inline-block; vertical-align:middle; margin-right:6px;
  }
  .blue{ background:#3aa0ff; }
  .red{ background:#ff5252; }

  .overlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.35);
    z-index:10;
    pointer-events:none;
  }
  .overlay .box{
    background:rgba(17,24,38,.95);
    border:1px solid rgba(74,163,255,.5);
    border-radius:16px;
    padding:18px 22px;
    font-size:18px;
    box-shadow:0 20px 60px rgba(0,0,0,.55);
  }
</style>
</head>
<body>

<div class="wrap">
  <div class="card">
    <canvas id="board" width="520" height="520"></canvas>
    <div class="tiny" style="margin-top:8px; line-height:1.6;">
      ＜ルール＞<br>
      盤は7×7の交点。外枠には置けません。反転はオセロと同じ。勝利条件は「5個ちょうど」（6連以上は勝ちになりません）。
    </div>
  </div>

  <div class="card">
    <div class="row">
      <label>対戦</label>
      <select id="mode">
        <option value="pvp">人 vs 人</option>
        <option value="cpu">人 vs CPU</option>
      </select>

      <span id="cpuColorWrap" style="display:none;">
        <label style="margin-left:8px;">あなたの手番</label>
        <select id="humanColor">
          <option value="black">黒（先手）</option>
          <option value="white">白（後手）</option>
        </select>
      </span>

      <span id="difficultyWrap" style="display:none;">
        <label style="margin-left:8px;">CPU難易度</label>
        <select id="difficulty">
          <option value="easy">弱</option>
          <option value="medium">中</option>
          <option value="strong">強</option>
        </select>
      </span>
    </div>

    <div class="row" style="margin-top:6px;">
      <button id="newGame">新規ゲーム</button>
      <button id="undo">Undo</button>

      <span style="margin-left:auto;"></span>

      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="showSafe" />
        安全手を表示（あなたの手番のみ）
      </label>
    </div>

    <div class="status" style="margin-top:10px;">
      <div><strong id="turnText">黒番</strong> <span id="resultText" class="tiny"></span></div>
      <div class="tiny" id="countText">黒: 0 / 白: 0　手数: 0</div>
      <div class="tiny">
        <span class="hintdot blue"></span>黒の安全手　
        <span style="margin-left:10px;"></span>
        <span class="hintdot red"></span>白の安全手
      </div>
      <div class="tiny">
        クリック/タップで着手。Undoは直前手を戻します（CPU戦では「あなたの手＋CPUの手」をまとめて戻します）。
      </div>
    </div>
  </div>
</div>

<div class="overlay" id="thinking">
  <div class="box">思考中…</div>
</div>

<script>
(() => {
  "use strict";

  /* =========================
     Core rules & board
  ========================= */
  const SIZE = 7;
  const EMPTY = 0, BLACK = 1, WHITE = 2;

  const dirs8 = [
    [-1,-1],[-1,0],[-1,1],
    [0,-1],       [0,1],
    [1,-1],[1,0],[1,1]
  ];
  const checkDirs = [[1,0],[0,1],[1,1],[1,-1]];
  const opp = c => (c===BLACK?WHITE:BLACK);
  const inside = (r,c) => (r>=0 && r<SIZE && c>=0 && c<SIZE);

  const makeBoard = () => Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY));
  const cloneBoard = b => b.map(row => row.slice());

  function boardCount(b){
    let bc=0,wc=0;
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(b[r][c]===BLACK) bc++;
        else if(b[r][c]===WHITE) wc++;
      }
    }
    return {bc,wc, stones: bc+wc};
  }

  function flips(b, r, c, col){
    const out = [];
    const o = opp(col);
    for(const [dr,dc] of dirs8){
      let rr=r+dr, cc=c+dc;
      const tmp=[];
      while(inside(rr,cc) && b[rr][cc]===o){
        tmp.push([rr,cc]);
        rr+=dr; cc+=dc;
      }
      if(tmp.length && inside(rr,cc) && b[rr][cc]===col){
        for(const p of tmp) out.push(p);
      }
    }
    return out;
  }

  function applyMove(b, r, c, col){
    if(!inside(r,c)) return null;
    if(b[r][c]!==EMPTY) return null;
    const f = flips(b,r,c,col);
    const nb = cloneBoard(b);
    nb[r][c] = col;
    for(const [rr,cc] of f) nb[rr][cc]=col;
    return { board: nb, flipped: f };
  }

  function legalMoves(b){
    const m=[];
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(b[r][c]===EMPTY) m.push([r,c]);
      }
    }
    return m;
  }

  /* =========================
     Win: exact five + line
  ========================= */
  function findExactFiveLine(b, col){
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(b[r][c]!==col) continue;

        for(const [dr,dc] of checkDirs){
          const pr=r-dr, pc=c-dc;
          if(inside(pr,pc) && b[pr][pc]===col) continue; // not a start

          let ok=true;
          for(let k=0;k<5;k++){
            const rr=r+dr*k, cc=c+dc*k;
            if(!inside(rr,cc) || b[rr][cc]!==col){ ok=false; break; }
          }
          if(!ok) continue;

          const nr=r+dr*5, nc=c+dc*5;
          if(inside(nr,nc) && b[nr][nc]===col) continue; // 6+ is NOT win

          return { from:{r,c}, to:{ r:r+dr*4, c:c+dc*4 }, col };
        }
      }
    }
    return null;
  }
  const hasExactFive = (b,col) => !!findExactFiveLine(b,col);

  /* =========================
     UI / State
  ========================= */
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");

  const elMode = document.getElementById("mode");
  const elHumanColor = document.getElementById("humanColor");
  const elDiff = document.getElementById("difficulty");
  const wrapHuman = document.getElementById("cpuColorWrap");
  const wrapDiff = document.getElementById("difficultyWrap");
  const elShowSafe = document.getElementById("showSafe");

  const btnNew = document.getElementById("newGame");
  const btnUndo = document.getElementById("undo");

  const turnText = document.getElementById("turnText");
  const resultText = document.getElementById("resultText");
  const countText = document.getElementById("countText");

  const thinkingOverlay = document.getElementById("thinking");
  const showThinking = on => (thinkingOverlay.style.display = on ? "flex" : "none");

  let game = null;
  let isCpuThinking = false;

  const colorName = c => (c===BLACK ? "黒" : "白");
  const currentTurnName = () => (game.turn===BLACK ? "黒番" : "白番");

  function isHumanTurn(){
    if(game.mode !== "cpu") return true;
    return game.turn === game.humanCol;
  }

  function pushHistory(){
    game.history.push({
      board: cloneBoard(game.board),
      turn: game.turn,
      over: game.over,
      winner: game.winner,
      winLine: game.winLine ? JSON.parse(JSON.stringify(game.winLine)) : null
    });
  }

  function popHistory(steps=1){
    while(steps-- > 0 && game.history.length > 1){
      game.history.pop();
    }
    const last = game.history[game.history.length-1];
    game.board = cloneBoard(last.board);
    game.turn = last.turn;
    game.over = last.over;
    game.winner = last.winner;
    game.winLine = last.winLine;
  }

  function updateUI(){
    if(elMode.value === "cpu"){
      wrapHuman.style.display = "";
      wrapDiff.style.display = "";
    }else{
      wrapHuman.style.display = "none";
      wrapDiff.style.display = "none";
    }

    turnText.textContent = game.over ? "対局終了" : currentTurnName();
    resultText.textContent = game.over
      ? (game.winner ? `（${colorName(game.winner)}の勝ち）` : "（引き分け）")
      : "";

    const {bc,wc,stones} = boardCount(game.board);
    countText.textContent = `黒: ${bc} / 白: ${wc}　手数: ${stones}`;

    btnUndo.disabled = (game.history.length<=1) || isCpuThinking;
    btnNew.disabled = isCpuThinking;

    draw();
  }

  /* =========================
     Drawing
  ========================= */
  function draw(){
    const W = canvas.width, H=canvas.height;
    ctx.clearRect(0,0,W,H);

    const pad = 50;
    const grid = (W - 2*pad) / (SIZE-1);
    const ox = pad, oy = pad;

    // grid
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    for(let i=0;i<SIZE;i++){
      ctx.beginPath();
      ctx.moveTo(ox, oy + i*grid);
      ctx.lineTo(ox + (SIZE-1)*grid, oy + i*grid);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(ox + i*grid, oy);
      ctx.lineTo(ox + i*grid, oy + (SIZE-1)*grid);
      ctx.stroke();
    }

    // coords
    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.font = "14px system-ui";
    for(let c=0;c<SIZE;c++){
      ctx.fillText(String.fromCharCode(97+c), ox + c*grid - 4, oy - 18);
    }
    for(let r=0;r<SIZE;r++){
      ctx.fillText(String(1+r), ox - 22, oy + r*grid + 5);
    }

    // safe moves overlay (human turn only)
    let safeSet = null;
    if(elShowSafe.checked && !game.over && isHumanTurn()){
      safeSet = computeSafeMoves(game.board, game.turn);
    }
    if(safeSet){
      for(const key of safeSet){
        const [r,c] = key.split(",").map(Number);
        const x = ox + c*grid;
        const y = oy + r*grid;
        ctx.beginPath();
        ctx.arc(x,y,8,0,Math.PI*2);
        ctx.fillStyle = (game.turn===BLACK) ? "rgba(58,160,255,.95)" : "rgba(255,82,82,.95)";
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,.25)";
        ctx.stroke();
      }
    }

    // stones
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const v = game.board[r][c];
        if(v===EMPTY) continue;
        const x = ox + c*grid;
        const y = oy + r*grid;

        ctx.beginPath();
        ctx.arc(x+2,y+3,20,0,Math.PI*2);
        ctx.fillStyle = "rgba(0,0,0,.22)";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(x,y,20,0,Math.PI*2);
        if(v===BLACK){
          const g = ctx.createRadialGradient(x-6,y-6,4, x,y,24);
          g.addColorStop(0,"#444");
          g.addColorStop(1,"#070707");
          ctx.fillStyle = g;
        }else{
          const g = ctx.createRadialGradient(x-6,y-6,4, x,y,24);
          g.addColorStop(0,"#fff");
          g.addColorStop(1,"#d9d9d9");
          ctx.fillStyle = g;
        }
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,.25)";
        ctx.stroke();
      }
    }

    // WIN LINE (solid only)
    if(game.over && game.winLine){
      const {from,to,col} = game.winLine;
      const x1 = ox + from.c*grid;
      const y1 = oy + from.r*grid;
      const x2 = ox + to.c*grid;
      const y2 = oy + to.r*grid;

      const main = (col===BLACK) ? "rgba(58,160,255,.95)" : "rgba(255,82,82,.95)";

      ctx.lineCap = "round";

      // shadow
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.lineWidth = 12;
      ctx.strokeStyle = "rgba(0,0,0,.25)";
      ctx.stroke();

      // main
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.lineWidth = 8;
      ctx.strokeStyle = main;
      ctx.stroke();
    }

    // end overlay
    if(game.over){
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(0, H/2-34, W, 68);
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.font = "bold 22px system-ui";
      const t = game.winner ? `${colorName(game.winner)}の勝ち` : "引き分け";
      const w = ctx.measureText(t).width;
      ctx.fillText(t, (W-w)/2, H/2+8);
    }
  }

  function screenToRC(x,y){
    const W = canvas.width;
    const pad = 50;
    const grid = (W - 2*pad) / (SIZE-1);
    const ox = pad, oy = pad;

    const c = Math.round((x - ox)/grid);
    const r = Math.round((y - oy)/grid);
    if(!inside(r,c)) return null;

    const ix = ox + c*grid;
    const iy = oy + r*grid;
    const dist = Math.hypot(x-ix,y-iy);
    if(dist > grid*0.38) return null;

    return {r,c};
  }

  /* =========================
     Safe move display
  ========================= */
  function computeSafeMoves(b, turnCol){
    const moves = legalMoves(b);
    const safe = new Set();
    for(const [r,c] of moves){
      const res = applyMove(b,r,c,turnCol);
      if(!res) continue;
      const nb = res.board;

      if(hasExactFive(nb, turnCol)){
        safe.add(`${r},${c}`);
        continue;
      }

      const op = opp(turnCol);
      const replies = legalMoves(nb);
      let oppWins = false;
      for(const [rr,cc] of replies){
        const rres = applyMove(nb, rr, cc, op);
        if(!rres) continue;
        if(hasExactFive(rres.board, op)){
          oppWins = true;
          break;
        }
      }
      if(!oppWins) safe.add(`${r},${c}`);
    }
    return safe;
  }

  /* =========================
     Game flow
  ========================= */
  function maybeEndAfterMove(){
    const bl = findExactFiveLine(game.board, BLACK);
    if(bl){
      game.over = true; game.winner = BLACK; game.winLine = bl;
      return true;
    }
    const wl = findExactFiveLine(game.board, WHITE);
    if(wl){
      game.over = true; game.winner = WHITE; game.winLine = wl;
      return true;
    }
    if(legalMoves(game.board).length===0){
      game.over = true; game.winner = null; game.winLine = null;
      return true;
    }
    return false;
  }

  /* =========================
     Timing helpers
  ========================= */
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const nextFrame = () => new Promise(r => requestAnimationFrame(() => r()));
  const nowMs = () => performance.now();

  async function playAt(r,c){
    if(game.over) return;
    if(isCpuThinking) return;
    if(game.mode==="cpu" && game.turn===game.cpuCol) return;

    const res = applyMove(game.board, r,c, game.turn);
    if(!res) return;

    game.board = res.board;
    game.turn = opp(game.turn);

    maybeEndAfterMove();
    pushHistory();
    updateUI();

    // Important: flush paint before CPU starts thinking (removes input lag)
    if(game.mode==="cpu" && !game.over){
      await nextFrame();
      await sleep(0);
      maybeCpuMove();
    }
  }

  function undo(){
    if(isCpuThinking) return;
    if(game.history.length<=1) return;
    if(game.mode==="cpu") popHistory(2);
    else popHistory(1);
    updateUI();
  }

  function newGame(){
    const mode = elMode.value;
    const humanIsBlack = (elHumanColor.value === "black");
    const humanCol = humanIsBlack ? BLACK : WHITE;
    const cpuCol = opp(humanCol);

    game = {
      mode,
      board: makeBoard(),
      turn: BLACK,
      over: false,
      winner: null,
      winLine: null,
      history: [],
      humanCol,
      cpuCol,
    };

    elShowSafe.checked = false;
    pushHistory();
    updateUI();
    maybeCpuMove();
  }

  /* =========================
     CPU AI (Strong) tweaks:
     - New time budget: 3s / 7s / 20s
     - PV priority
     - TT (transposition table)
     - Dynamic candidate count
     - Quiescence search (tactical extension)
     - Root extensions (top K root moves +1 ply)
  ========================= */

  function timeBudgetMs(){
    const stones = boardCount(game.board).stones;
    const ply = stones + 1;
    const d = elDiff.value;

    if(d==="easy") return 250;
    if(d==="medium") return 1500;

    // strong: new budgets
    if(ply <= 6) return 3000;
    if(ply <= 14) return 7000;
    return 20000;
  }

  async function maybeCpuMove(){
    if(game.mode!=="cpu") return;
    if(game.over) return;
    if(game.turn !== game.cpuCol) return;

    isCpuThinking = true;
    updateUI();

    const budget = timeBudgetMs();
    const cpuTurnStart = nowMs();
    const thinkLabelTimer = setTimeout(()=>{ showThinking(true); }, 3000);

    try{
      const move = await pickCpuMove(game.board, game.turn, budget, elDiff.value);

      // minimum tempo: 0.5s
      const elapsed = nowMs() - cpuTurnStart;
      if(elapsed < 500) await sleep(500 - elapsed);

      clearTimeout(thinkLabelTimer);
      showThinking(false);

      if(game.over) return;

      if(move){
        const res = applyMove(game.board, move.r, move.c, game.turn);
        if(res) game.board = res.board;
      }
      game.turn = opp(game.turn);

      maybeEndAfterMove();
      pushHistory();
    } finally {
      clearTimeout(thinkLabelTimer);
      showThinking(false);
      isCpuThinking = false;
      updateUI();
    }
  }

  function immediateWinMove(b, col){
    for(const [r,c] of legalMoves(b)){
      const res = applyMove(b,r,c,col);
      if(res && hasExactFive(res.board, col)) return {r,c};
    }
    return null;
  }
  function blockOpponentWinMove(b, col){
    const op = opp(col);
    for(const [r,c] of legalMoves(b)){
      const res = applyMove(b,r,c,op);
      if(res && hasExactFive(res.board, op)) return {r,c};
    }
    return null;
  }

  function countImmediateExactWins(b, col){
    let cnt=0;
    for(const [r,c] of legalMoves(b)){
      const res = applyMove(b,r,c,col);
      if(res && hasExactFive(res.board, col)){
        cnt++;
        if(cnt>=2) return 2;
      }
    }
    return cnt;
  }

  function evalPos(b, me){
    const op = opp(me);
    if(hasExactFive(b, me)) return 1e15;
    if(hasExactFive(b, op)) return -1e15;

    let score = 0;

    // center preference
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const v=b[r][c];
        if(v===EMPTY) continue;
        const cd = Math.abs(r-3)+Math.abs(c-3);
        const w = 6 - cd;
        score += (v===me ? +w : -w);
      }
    }

    function lineFeature(r, c, col, dr, dc){
      let a=0, rr=r+dr, cc=c+dc;
      while(inside(rr,cc) && b[rr][cc]===col){ a++; rr+=dr; cc+=dc; }
      const end1 = (inside(rr,cc) && b[rr][cc]===EMPTY) ? 1 : 0;

      let bcnt=0; rr=r-dr; cc=c-dc;
      while(inside(rr,cc) && b[rr][cc]===col){ bcnt++; rr-=dr; cc-=dc; }
      const end2 = (inside(rr,cc) && b[rr][cc]===EMPTY) ? 1 : 0;

      return {len:1+a+bcnt, open:end1+end2};
    }

    function add(col, sign){
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          if(b[r][c]!==col) continue;
          for(const [dr,dc] of checkDirs){
            const f = lineFeature(r,c,col,dr,dc);
            if(f.len>=4){
              score += sign * (f.open===2 ? 700000 : f.open===1 ? 160000 : 24000);
            }else if(f.len===3){
              score += sign * (f.open===2 ? 28000 : f.open===1 ? 7600 : 700);
            }else if(f.len===2){
              score += sign * (f.open===2 ? 950 : f.open===1 ? 240 : 28);
            }
          }
        }
      }
    }
    add(me,+1); add(op,-1);

    const myWin = countImmediateExactWins(b, me);
    const opWin = countImmediateExactWins(b, op);
    if(myWin>=2) score += 5e8;
    else if(myWin===1) score += 8e6;
    if(opWin>=2) score -= 6e8;
    else if(opWin===1) score -= 1.2e7;

    return score;
  }

  function candidateMoves(b, radius){
    const {stones} = boardCount(b);
    if(stones===0){
      return [[3,3],[3,2],[2,3],[3,4],[4,3],[2,2],[4,4],[2,4],[4,2]];
    }
    if(stones>=36) return legalMoves(b);

    const set = new Set();
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(b[r][c]===EMPTY) continue;
        for(let dr=-radius; dr<=radius; dr++){
          for(let dc=-radius; dc<=radius; dc++){
            const rr=r+dr, cc=c+dc;
            if(inside(rr,cc) && b[rr][cc]===EMPTY){
              set.add(rr*10+cc);
            }
          }
        }
      }
    }
    const out=[];
    for(const v of set) out.push([Math.floor(v/10), v%10]);
    return out;
  }

  function orderMoves(b, col, maxCand){
    const {stones} = boardCount(b);
    const radius = stones<=10 ? 3 : 4;
    const cand = candidateMoves(b, radius);
    const op = opp(col);

    // detect opponent immediate wins (to prioritize blocks)
    const oppWinSet = new Set();
    for(const [r,c] of cand){
      const t = applyMove(b,r,c,op);
      if(t && hasExactFive(t.board, op)) oppWinSet.add(r*10+c);
    }

    const scored = [];
    for(const [r,c] of cand){
      const t = applyMove(b,r,c,col);
      if(!t) continue;

      const winNow = hasExactFive(t.board, col) ? 1 : 0;
      const blocks = oppWinSet.has(r*10+c) ? 1 : 0;

      const forks = countImmediateExactWins(t.board, col);
      const forkBonus = forks>=2 ? 1 : forks===1 ? 0.2 : 0;

      const rough = evalPos(t.board, col);
      const pri = winNow*1e18 + blocks*8e17 + forkBonus*4e16 + rough;
      scored.push({r,c,pri});
    }
    scored.sort((a,b)=> b.pri - a.pri);
    return scored.slice(0, maxCand).map(x=>({r:x.r,c:x.c}));
  }

  function terminalScore(b, me){
    const op = opp(me);
    if(hasExactFive(b, me)) return 1e15;
    if(hasExactFive(b, op)) return -1e15;
    if(legalMoves(b).length===0) return 0;
    return null;
  }

  // --- TT (simple, per-search) ---
  const TT_EXACT = 0, TT_LOWER = 1, TT_UPPER = 2;

  function boardKey(b, turn){
    // 7x7 = 49 cells. Simple string key is ok; keep it compact.
    // "t|" + digits 0/1/2
    let s = (turn===BLACK ? "B|" : "W|");
    for(let r=0;r<SIZE;r++){
      const row = b[r];
      for(let c=0;c<SIZE;c++){
        s += row[c]; // 0/1/2
      }
    }
    return s;
  }

  function dynamicMaxCand(stones, depth, remainMs){
    // Wide early, sharper deep, shrink when time is tight
    if(stones <= 2) return 22;
    let base = (stones <= 10) ? 20 : 26;
    if(depth >= 7) base -= 6;
    if(depth >= 9) base -= 4;
    if(remainMs < 900) base -= 6;
    if(remainMs < 450) base -= 4;
    return Math.max(12, Math.min(30, base));
  }

  function shouldQuiesce(b, me){
    const op = opp(me);
    // "noisy" if immediate win threat exists or fork exists
    if(countImmediateExactWins(b, me) >= 1) return true;
    if(countImmediateExactWins(b, op) >= 1) return true;
    return false;
  }

  function forcingMoves(b, turn){
    // Only "tactical" moves: winning, blocking opponent immediate win, or creating fork
    const win = immediateWinMove(b, turn);
    if(win) return [win];

    const op = opp(turn);
    const needBlock = blockOpponentWinMove(b, turn);
    const out = [];

    // collect several block candidates (could be >1 threats)
    const moves = legalMoves(b);
    for(const [r,c] of moves){
      const tOpp = applyMove(b,r,c,op);
      if(tOpp && hasExactFive(tOpp.board, op)){
        out.push({r,c}); // blocking square (by playing there as turn)
      }
    }
    if(out.length){
      // ensure unique
      const seen = new Set();
      const uniq = [];
      for(const m of out){
        const k = m.r*10+m.c;
        if(!seen.has(k)){ seen.add(k); uniq.push(m); }
      }
      return uniq;
    }

    // forks
    const cand = orderMoves(b, turn, 18);
    const forks = [];
    for(const m of cand){
      const t = applyMove(b,m.r,m.c,turn);
      if(!t) continue;
      if(countImmediateExactWins(t.board, turn) >= 2){
        forks.push(m);
        if(forks.length>=6) break;
      }
    }
    return forks;
  }

  async function quiescence(b, qDepth, alpha, beta, me, turn, deadline, tt){
    if(nowMs() > deadline) return evalPos(b, me);

    const term = terminalScore(b, me);
    if(term !== null) return term;

    const stand = evalPos(b, me);
    if(qDepth <= 0) return stand;

    // If position is calm, just stand pat
    if(!shouldQuiesce(b, me)) return stand;

    // alpha-beta stand-pat handling
    if(turn === me){
      if(stand > alpha) alpha = stand;
      if(alpha >= beta) return alpha;
    }else{
      if(stand < beta) beta = stand;
      if(alpha >= beta) return beta;
    }

    const moves = forcingMoves(b, turn);
    if(!moves.length) return stand;

    const maximizing = (turn===me);
    let best = maximizing ? -Infinity : Infinity;

    for(const m of moves){
      if(nowMs() > deadline) break;
      const t = applyMove(b, m.r, m.c, turn);
      if(!t) continue;

      const val = await quiescence(t.board, qDepth-1, alpha, beta, me, opp(turn), deadline, tt);

      if(maximizing){
        if(val > best) best = val;
        if(best > alpha) alpha = best;
      }else{
        if(val < best) best = val;
        if(best < beta) beta = best;
      }
      if(beta <= alpha) break;
    }
    return (best===Infinity || best===-Infinity) ? stand : best;
  }

  async function alphabeta(b, depth, alpha, beta, me, turn, deadline, tt){
    if(nowMs() > deadline) return evalPos(b, me);

    const term = terminalScore(b, me);
    if(term !== null) return term;

    // TT probe
    const key = boardKey(b, turn);
    const hit = tt.get(key);
    if(hit && hit.depth >= depth){
      if(hit.flag === TT_EXACT) return hit.val;
      if(hit.flag === TT_LOWER) alpha = Math.max(alpha, hit.val);
      else if(hit.flag === TT_UPPER) beta = Math.min(beta, hit.val);
      if(beta <= alpha) return hit.val;
    }

    if(depth === 0){
      // Quiescence: only extend tactically "noisy" positions a bit
      const val = await quiescence(b, 2, alpha, beta, me, turn, deadline, tt);
      tt.set(key, {depth, val, flag: TT_EXACT});
      return val;
    }

    const maximizing = (turn===me);
    let best = maximizing ? -Infinity : Infinity;

    const {stones} = boardCount(b);
    const remain = Math.max(0, deadline - nowMs());
    const maxCand = dynamicMaxCand(stones, depth, remain);
    const moves = orderMoves(b, turn, maxCand);
    if(!moves.length){
      const val = evalPos(b, me);
      tt.set(key, {depth, val, flag: TT_EXACT});
      return val;
    }

    const a0 = alpha, b0 = beta;

    for(const m of moves){
      if(nowMs() > deadline) break;
      const t = applyMove(b, m.r, m.c, turn);
      if(!t) continue;

      const val = await alphabeta(t.board, depth-1, alpha, beta, me, opp(turn), deadline, tt);

      if(maximizing){
        if(val > best) best = val;
        if(best > alpha) alpha = best;
      }else{
        if(val < best) best = val;
        if(best < beta) beta = best;
      }
      if(beta <= alpha) break;
    }

    // TT store with bound type
    let flag = TT_EXACT;
    if(best <= a0) flag = TT_UPPER;
    else if(best >= b0) flag = TT_LOWER;

    // keep TT bounded a bit (per-search, but still)
    if(tt.size > 60000){
      tt.clear();
    }
    tt.set(key, {depth, val: best, flag});
    return best;
  }

  async function iterativeDeepening(rootBoard, me, budgetMs, depthCap){
    const start = nowMs();
    const deadline = start + budgetMs;

    const tt = new Map(); // per move (cleared each pick)
    let bestMove = null;

    // Root extensions: top K moves get +1 ply
    const {stones} = boardCount(rootBoard);
    const rootTopK = stones <= 10 ? 6 : 4;

    for(let depth=3; depth<=depthCap; depth++){
      if(nowMs() > deadline) break;

      const remain = Math.max(0, deadline - nowMs());
      const maxCand = dynamicMaxCand(stones, depth, remain);
      let moves = orderMoves(rootBoard, me, maxCand);
      if(!moves.length) break;

      // PV priority
      if(bestMove){
        const idx = moves.findIndex(m => m.r===bestMove.r && m.c===bestMove.c);
        if(idx > 0){
          const [pv] = moves.splice(idx,1);
          moves.unshift(pv);
        }
      }

      let localBest = bestMove || moves[0];
      let localBestVal = -Infinity;

      for(let i=0;i<moves.length;i++){
        if(nowMs() > deadline) break;

        const m = moves[i];
        const t = applyMove(rootBoard, m.r, m.c, me);
        if(!t) continue;

        // Root extension: top-K moves get one extra ply
        const extra = (i < rootTopK) ? 1 : 0;
        const searchDepth = Math.max(0, depth - 1 + extra);

        const val = await alphabeta(t.board, searchDepth, -Infinity, Infinity, me, opp(me), deadline, tt);

        if(val > localBestVal){
          localBestVal = val;
          localBest = m;
        }

        // yield occasionally (keeps iPhone responsive)
        if(depth >= 5) await sleep(0);
      }

      bestMove = localBest;
    }
    return bestMove;
  }

  async function pickCpuMove(b, col, budgetMs, difficulty){
    // Tactical shortcuts first
    const win = immediateWinMove(b, col);
    if(win) return win;
    const block = blockOpponentWinMove(b, col);
    if(block) return block;

    if(difficulty==="easy"){
      const moves = orderMoves(b, col, 10);
      if(!moves.length) return null;
      return moves[Math.floor(Math.random()*Math.min(3,moves.length))];
    }

    if(difficulty==="medium"){
      // medium: still uses TT + quiescence + PV etc, but lower cap
      return await iterativeDeepening(b, col, Math.min(budgetMs, 2000), 9);
    }

    // strong: cap tuned for mobile
    return await iterativeDeepening(b, col, budgetMs, 14);
  }

  /* =========================
     Events
  ========================= */
  btnNew.addEventListener("click", ()=> newGame());
  btnUndo.addEventListener("click", ()=> undo());
  elMode.addEventListener("change", ()=> newGame());
  elHumanColor.addEventListener("change", ()=> newGame());
  elDiff.addEventListener("change", ()=> {});
  elShowSafe.addEventListener("change", ()=> draw());

  canvas.addEventListener("click", (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    const rc = screenToRC(x,y);
    if(!rc) return;
    playAt(rc.r, rc.c);
  });
  canvas.addEventListener("touchend", (ev)=>{
    const t = ev.changedTouches[0];
    if(!t) return;
    const rect = canvas.getBoundingClientRect();
    const x = (t.clientX - rect.left) * (canvas.width / rect.width);
    const y = (t.clientY - rect.top) * (canvas.height / rect.height);
    const rc = screenToRC(x,y);
    if(!rc) return;
    playAt(rc.r, rc.c);
  });

  /* =========================
     Init
  ========================= */
  newGame();
})();
</script>

</body>
</html>
