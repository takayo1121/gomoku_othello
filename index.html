<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>五目オセロ（交点 / 安全手OFF / CPU先後・難易度）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
  body{
    font-family:-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN",sans-serif;
    background:#f5f5f5;margin:0;padding:12px;
  }
  #status{font-weight:700;margin-bottom:8px}
  .controls{margin-bottom:10px}
  button,select{font-size:14px;margin-right:6px;padding:6px 10px}

  .board{
    width:min(92vw,520px);
    aspect-ratio:1/1;
    display:grid;
    grid-template-columns:repeat(9,1fr);
    background:#0a6a3a;
    border:2px solid #222;
  }

  .pt{
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
  }
  .pt::before{
    content:"";
    position:absolute;
    inset:0;
    background:
      linear-gradient(rgba(0,0,0,.35),rgba(0,0,0,.35)) center/100% 1px no-repeat,
      linear-gradient(90deg,rgba(0,0,0,.35),rgba(0,0,0,.35)) center/1px 100% no-repeat;
    opacity:.9;
  }

  .disabled{ cursor:not-allowed; opacity:.35; }

  .disc{
    width:62%;
    height:62%;
    border-radius:50%;
    box-shadow:0 2px 8px rgba(0,0,0,.35);
    border:1px solid rgba(0,0,0,.25);
    position:relative;
    z-index:3;
  }
  .black{background:#000;}
  .white{background:#fff;}

  .dot{
    width:10%;
    height:10%;
    border-radius:50%;
    background:rgba(0,0,0,.35);
    position:relative;
    z-index:2;
  }

  /* 安全手（表示ON時のみ） */
  .safe-fill{
    width:62%;
    height:62%;
    border-radius:50%;
    position:absolute;
    z-index:2;
    opacity:.85;
    box-shadow:0 2px 8px rgba(0,0,0,.22);
  }
  .safe-blue{ background:rgba(0,90,255,.92); } /* 黒番 */
  .safe-red{  background:rgba(220,0,0,.92); } /* 白番 */

  .note{font-size:12px;opacity:.85;line-height:1.5;margin-top:8px}
</style>
</head>

<body>
  <div id="status">準備中…</div>

  <div class="controls">
    <button id="undoBtn">Undo</button>
    <button id="restartBtn">リスタート</button>

    <select id="mode">
      <option value="pvp">人 vs 人</option>
      <option value="cpu">人 vs CPU</option>
    </select>

    <!-- CPU戦のときだけ表示 -->
    <select id="humanColor" title="CPU戦：あなたの色" style="display:none">
      <option value="black">あなた：黒（先手）</option>
      <option value="white">あなた：白（後手）</option>
    </select>

    <!-- CPU戦のときだけ表示 -->
    <select id="difficulty" title="CPU難易度" style="display:none">
      <option value="easy">難易度：弱</option>
      <option value="medium" selected>難易度：中</option>
      <option value="hard">難易度：強</option>
    </select>

    <button id="safeToggleBtn">安全手：OFF</button>
  </div>

  <div id="board" class="board"></div>

  <div class="note">
    安全手（塗り丸）：今そこに置いても、次の相手番で相手が即五連で勝てない手。<br>
    表示色：黒番＝青、白番＝赤（初期状態はOFF）<br>
    CPU戦では<strong>CPU番の安全手は表示しません</strong>。<br>
    CPU難易度：弱・中・強（中がデフォルト）
  </div>

<script>
(() => {
  const N=9, PLAY_MIN=1, PLAY_MAX=7;
  const EMPTY=0, BLACK=1, WHITE=2;
  const dirs8=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  const checkDirs=[[1,0],[0,1],[1,1],[1,-1]];

  let board, turn, gameOver, history;
  let showSafe = false; // デフォルトOFF

  const $board=document.getElementById("board");
  const $status=document.getElementById("status");
  const $mode=document.getElementById("mode");
  const $humanColor=document.getElementById("humanColor");
  const $difficulty=document.getElementById("difficulty");
  const $safeBtn=document.getElementById("safeToggleBtn");

  const opp=c=>c===BLACK?WHITE:BLACK;
  const inB=(r,c)=>r>=0&&r<N&&c>=0&&c<N;
  const playable=(r,c)=>r>=PLAY_MIN&&r<=PLAY_MAX&&c>=PLAY_MIN&&c<=PLAY_MAX;
  const clone=b=>b.map(r=>r.slice());

  const isCpuMode=()=> $mode.value==="cpu";
  const human=()=> $humanColor.value==="black"?BLACK:WHITE;
  const cpu=()=> opp(human());
  const isHumanTurn=()=> !isCpuMode() || turn===human();

  function updateCpuUiVisibility(){
    const on = isCpuMode();
    $humanColor.style.display = on ? "" : "none";
    $difficulty.style.display = on ? "" : "none";
  }

  function init(){
    board=Array.from({length:N},()=>Array(N).fill(EMPTY));
    turn=BLACK; gameOver=false; history=[];
    updateCpuUiVisibility();
    render(); updateStatus(); maybeCpu();
  }

  function flips(b,r,c,col){
    let f=[];
    for(const[dR,dC]of dirs8){
      let x=r+dR,y=c+dC,tmp=[];
      while(inB(x,y)&&b[x][y]===opp(col)){tmp.push([x,y]);x+=dR;y+=dC;}
      if(tmp.length&&inB(x,y)&&b[x][y]===col)f=f.concat(tmp);
    }
    return f;
  }

  function sim(b,r,c,col){
    if(!playable(r,c)||b[r][c]!==EMPTY)return null;
    const nb=clone(b); nb[r][c]=col;
    flips(nb,r,c,col).forEach(p=>nb[p[0]][p[1]]=col);
    return nb;
  }

  function hasFive(b,col){
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++)for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
      if(b[r][c]!==col)continue;
      for(const[dR,dC]of checkDirs){
        let n=1,x=r+dR,y=c+dC;
        while(inB(x,y)&&b[x][y]===col){ if(++n>=5) return true; x+=dR;y+=dC; }
      }
    }
    return false;
  }

  function legal(b){
    const m=[];
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++)for(let c=PLAY_MIN;c<=PLAY_MAX;c++)
      if(b[r][c]===EMPTY)m.push([r,c]);
    return m;
  }

  // 安全手（表示用）
  function safeMoves(b,col){
    const set=new Set(), o=opp(col);
    for(const[r,c]of legal(b)){
      const nb=sim(b,r,c,col);
      if(!nb)continue;
      if(hasFive(nb,col)){ set.add(`${r},${c}`); continue; }
      let oppWin=false;
      for(const[x,y]of legal(nb)){
        const nb2=sim(nb,x,y,o);
        if(nb2&&hasFive(nb2,o)){ oppWin=true; break; }
      }
      if(!oppWin)set.add(`${r},${c}`);
    }
    return set;
  }

  // ---------------------------
  // CPU 強化：候補手生成 + 評価 + ミニマックス
  // ---------------------------

  function anyStoneExists(b){
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++)for(let c=PLAY_MIN;c<=PLAY_MAX;c++)
      if(b[r][c]!==EMPTY) return true;
    return false;
  }

  // 既存の石の近傍（距離<=2）だけを候補にして計算量を落とす
  function candidateMoves(b, radius=2){
    const has = anyStoneExists(b);
    if(!has){
      // 初手は中央優先（交点(4,4)が中心）
      return [[4,4],[4,3],[3,4],[4,5],[5,4]];
    }
    const cand = new Set();
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++){
      for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
        if(b[r][c]===EMPTY) continue;
        for(let dr=-radius; dr<=radius; dr++){
          for(let dc=-radius; dc<=radius; dc++){
            const rr=r+dr, cc=c+dc;
            if(playable(rr,cc) && b[rr][cc]===EMPTY) cand.add(`${rr},${cc}`);
          }
        }
      }
    }
    const out=[];
    for(const s of cand){
      const [r,c]=s.split(",").map(Number);
      out.push([r,c]);
    }
    return out;
  }

  // ある地点に置いたとき、自分色が何個連なるか（単純に周囲連結を見る）
  function lineScore(b, r, c, col, dr, dc){
    let cnt1=0, x=r+dr, y=c+dc;
    while(playable(x,y) && b[x][y]===col){ cnt1++; x+=dr; y+=dc; }
    let cnt2=0; x=r-dr; y=c-dc;
    while(playable(x,y) && b[x][y]===col){ cnt2++; x-=dr; y-=dc; }
    return 1+cnt1+cnt2;
  }

  // 盤面評価（CPU視点）
  function evaluate(b, cpuCol){
    const humCol = opp(cpuCol);

    // 勝敗は最優先
    if(hasFive(b, cpuCol)) return 1e9;
    if(hasFive(b, humCol)) return -1e9;

    let score = 0;

    // 中央寄り（軽く）
    for(let r=PLAY_MIN;r<=PLAY_MAX;r++){
      for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
        const v=b[r][c];
        if(v===EMPTY) continue;
        const centerDist = Math.abs(r-4)+Math.abs(c-4);
        const w = 6 - centerDist; // だいたい 0..6
        if(v===cpuCol) score += w;
        else score -= w;
      }
    }

    // 連の強さ（4,3,2 を重く）
    // 各石を起点に4方向だけ見る（重複はあるが軽量）
    function addFor(col, sign){
      for(let r=PLAY_MIN;r<=PLAY_MAX;r++){
        for(let c=PLAY_MIN;c<=PLAY_MAX;c++){
          if(b[r][c]!==col) continue;
          for(const [dr,dc] of checkDirs){
            // ここを起点に伸びる最大連（片方向）
            let len=1, x=r+dr, y=c+dc;
            while(playable(x,y) && b[x][y]===col){ len++; x+=dr; y+=dc; }
            if(len>=4) score += sign*1200;
            else if(len===3) score += sign*160;
            else if(len===2) score += sign*20;
          }
        }
      }
    }
    addFor(cpuCol, +1);
    addFor(humCol, -1);

    return score;
  }

  function difficultyDepth(){
    const d = $difficulty.value;
    if(d==="easy") return 1;
    if(d==="medium") return 2;
    return 3; // hard
  }

  function maxCandidates(){
    // 深さが深いほど候補を絞る（速度優先）
    const d = $difficulty.value;
    if(d==="easy") return 14;
    if(d==="medium") return 12;
    return 10;
  }

  // 候補手を「良さそう順」に並べる（先に良い手を探索→αβが効く）
  function orderedMoves(b, col){
    const cand = candidateMoves(b, 2);
    const scored=[];
    for(const [r,c] of cand){
      const nb = sim(b,r,c,col);
      if(!nb) continue;
      // 置いた直後の局所的な連の伸びを優先
      let local=0;
      for(const [dr,dc] of checkDirs){
        local = Math.max(local, lineScore(nb, r, c, col, dr, dc));
      }
      // 勝ち手は最優先
      if(hasFive(nb, col)) local += 100;
      scored.push({r,c,local, nb});
    }
    scored.sort((a,b)=>b.local-a.local);
    const limit = maxCandidates();
    return scored.slice(0, limit).map(x=>[x.r,x.c]);
  }

  function minimax(b, depth, alpha, beta, maximizing, cpuCol){
    const humCol = opp(cpuCol);

    // 終端
    if(depth===0 || hasFive(b,cpuCol) || hasFive(b,humCol)){
      return evaluate(b, cpuCol);
    }

    const col = maximizing ? cpuCol : humCol;
    const moves = orderedMoves(b, col);
    if(moves.length===0) return evaluate(b, cpuCol);

    if(maximizing){
      let best = -Infinity;
      for(const [r,c] of moves){
        const nb = sim(b,r,c,col);
        if(!nb) continue;
        const v = minimax(nb, depth-1, alpha, beta, false, cpuCol);
        if(v>best) best=v;
        if(best>alpha) alpha=best;
        if(beta<=alpha) break;
      }
      return best;
    }else{
      let best = Infinity;
      for(const [r,c] of moves){
        const nb = sim(b,r,c,col);
        if(!nb) continue;
        const v = minimax(nb, depth-1, alpha, beta, true, cpuCol);
        if(v<best) best=v;
        if(best<beta) beta=best;
        if(beta<=alpha) break;
      }
      return best;
    }
  }

  function chooseCpuMove(){
    const cpuCol = cpu();
    const humCol = human();

    const moves = orderedMoves(board, cpuCol);

    // まず即勝ち
    for(const [r,c] of moves){
      const nb = sim(board,r,c,cpuCol);
      if(nb && hasFive(nb, cpuCol)) return [r,c];
    }
    // 次に相手の即勝ちをブロック（“ブロックすれば必ず止まる”とは限らないが実用的）
    // 相手の勝ち手を探して、その座標に打てるなら優先
    const humWins = orderedMoves(board, humCol);
    for(const [r,c] of humWins){
      const nb = sim(board,r,c,humCol);
      if(nb && hasFive(nb, humCol)){
        // その場所にCPUが打てるなら防ぐ
        if(board[r][c]===EMPTY && playable(r,c)) return [r,c];
      }
    }

    const depth = difficultyDepth();
    let bestMove = moves[0] || [4,4];
    let bestVal = -Infinity;

    // easyはさらにランダム性を少し入れて “弱さ” を作る
    const isEasy = $difficulty.value==="easy";

    for(const [r,c] of moves){
      const nb = sim(board,r,c,cpuCol);
      if(!nb) continue;
      const v = minimax(nb, depth-1, -Infinity, Infinity, false, cpuCol);

      // easy：評価が近い手から少しブレる
      const vv = isEasy ? (v + (Math.random()-0.5)*30) : v;

      if(vv > bestVal){
        bestVal = vv;
        bestMove = [r,c];
      }
    }
    return bestMove;
  }

  // ---------------------------
  // ゲーム進行
  // ---------------------------

  function move(r,c){
    if(gameOver||!playable(r,c)||board[r][c]!==EMPTY)return;
    if(isCpuMode()&&!isHumanTurn())return;

    history.push({board:clone(board),turn,gameOver});
    board[r][c]=turn;
    flips(board,r,c,turn).forEach(p=>board[p[0]][p[1]]=turn);

    if(hasFive(board,turn)){ gameOver=true; render(); updateStatus(`${turn===BLACK?"黒":"白"}の勝ち！`); return; }
    turn=opp(turn); render(); updateStatus(); maybeCpu();
  }

  function maybeCpu(){
    if(!isCpuMode()||gameOver||turn!==cpu())return;

    // UI固まり防止：少し遅延
    setTimeout(()=>{
      if(gameOver) return;

      history.push({board:clone(board),turn,gameOver});
      const [r,c] = chooseCpuMove();

      // まれに候補が空になることがあるので保険
      if(!(playable(r,c) && board[r][c]===EMPTY)){
        const fallback = legal(board)[0];
        if(!fallback) return;
        r = fallback[0]; c = fallback[1];
      }

      board[r][c]=turn;
      flips(board,r,c,turn).forEach(p=>board[p[0]][p[1]]=turn);

      if(hasFive(board,turn)){ gameOver=true; render(); updateStatus(`${turn===BLACK?"黒":"白"}の勝ち！`); return; }
      turn=opp(turn); render(); updateStatus();
    }, 220);
  }

  function updateStatus(msg){
    if(msg){$status.textContent=msg;return;}
    if(gameOver){$status.textContent="ゲーム終了";return;}
    if(!isCpuMode()){
      $status.textContent=turn===BLACK?"黒の手番":"白の手番";
      return;
    }
    const label = ($difficulty.value==="easy")?"弱":($difficulty.value==="medium")?"中":"強";
    $status.textContent=`手番：${turn===BLACK?"黒":"白"}${isHumanTurn()?"（あなた）":"（CPU）"} / CPU難易度：${label}`;
  }

  function render(){
    // 安全手表示条件：
    // - ON
    // - ゲーム中
    // - PvPなら手番ごと
    // - CPU戦なら「あなたの手番のみ」（CPU番は表示しない）
    const show = showSafe && !gameOver && (!isCpuMode()||isHumanTurn());
    const safes = show ? safeMoves(board,turn) : new Set();
    const cls = turn===WHITE?"safe-red":"safe-blue";

    $board.innerHTML="";
    for(let r=0;r<N;r++)for(let c=0;c<N;c++){
      const cell=document.createElement("div");
      cell.className="pt"+(playable(r,c)?"":" disabled");
      cell.onclick=()=>move(r,c);

      if(board[r][c]){
        const d=document.createElement("div");
        d.className="disc "+(board[r][c]===BLACK?"black":"white");
        cell.appendChild(d);
      }else if(playable(r,c)){
        if(show&&safes.has(`${r},${c}`)){
          const sf=document.createElement("div");
          sf.className="safe-fill "+cls;
          cell.appendChild(sf);
        }
        const dot=document.createElement("div"); dot.className="dot"; cell.appendChild(dot);
      }
      $board.appendChild(cell);
    }
  }

  // UIイベント
  document.getElementById("undoBtn").onclick=()=>{
    if(!history.length)return;
    const s=history.pop(); board=clone(s.board); turn=s.turn; gameOver=s.gameOver;
    render(); updateStatus();

    // CPU戦は「あなたの手番」まで戻す
    if(isCpuMode()&&!isHumanTurn()&&history.length){
      const s2=history.pop(); board=clone(s2.board); turn=s2.turn; gameOver=s2.gameOver;
      render(); updateStatus();
    }
  };

  document.getElementById("restartBtn").onclick=init;

  $mode.onchange=init;
  $humanColor.onchange=init;
  $difficulty.onchange=init;

  $safeBtn.onclick=()=>{
    showSafe=!showSafe;
    $safeBtn.textContent="安全手："+(showSafe?"ON":"OFF");
    render();
  };

  init();
})();
</script>
</body>
</html>
